#include "VsequenceLock.h"     // Generated by Verilator from your module
#include "verilated.h"
#include <iostream>
#include <cstdlib>

// Simulation time
vluint64_t main_time = 0;

// Verilator callback for time
double sc_time_stamp() {
    return main_time;
}

int main(int argc, char **argv) {
    Verilated::commandArgs(argc, argv);

    // Instantiate the DUT
    VsequenceLock* dut = new VsequenceLock;

    // Initialize inputs
    dut->clk = 0;
    dut->rst = 0;
    dut->button = 0;

    // Apply reset for a few cycles
    dut->rst = 1;
    for (int i = 0; i < 2; i++) {
        dut->clk = !dut->clk; dut->eval(); main_time++;
        dut->clk = !dut->clk; dut->eval(); main_time++;
    }
    dut->rst = 0; // Release reset

    std::cout << "Starting FSM simulation..." << std::endl;

    // Helper lambda to toggle clock
    auto tick = [&](int cycles = 1) {
        for (int i = 0; i < cycles; i++) {
            dut->clk = 1; dut->eval(); main_time++;
            dut->clk = 0; dut->eval(); main_time++;
        }
    };

    // Sequence: button = 1 -> 0 -> 1 -> 1
    // This should unlock the FSM.

    // Step 1: button high (S0 -> S1)
    dut->button = 1;
    tick();
    std::cout << "After Step 1: unlock = " << dut->unlock << std::endl;

    // Step 2: button low (S1 -> S2)
    dut->button = 0;
    tick();
    std::cout << "After Step 2: unlock = " << dut->unlock << std::endl;

    // Step 3: button high (S2 -> S3)
    dut->button = 1;
    tick();
    std::cout << "After Step 3: unlock = " << dut->unlock << std::endl;

    // Step 4: button high again (S3 -> S4 unlock)
    dut->button = 1;
    tick();
    std::cout << "After Step 4: unlock = " << dut->unlock << " (should be 1)" << std::endl;

    // Extra cycles just to observe stable unlock
    tick(3);
    std::cout << "Final unlock = " << dut->unlock << std::endl;

    // Cleanup
    dut->final();
    delete dut;
    return 0;
}